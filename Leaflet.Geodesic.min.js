/*! Leaflet.Geodesic  https://github.com/henrythasler/Leaflet.Geodesic*/
void 0===Number.prototype.toRadians&&(Number.prototype.toRadians=function(){return this*Math.PI/180}),void 0===Number.prototype.toDegrees&&(Number.prototype.toDegrees=function(){return 180*this/Math.PI})
var INTERSECT_LNG=179.999
L.Geodesic=L.MultiPolyline.extend({options:{color:"blue",steps:10,dash:1},initialize:function(t,a){this.options=this._merge_options(this.options,a),this.datum={},this.datum.ellipsoid={a:6378137,b:6356752.3142,f:1/298.257223563},L.MultiPolyline.prototype.initialize.call(this,t,this.options)},setLatLngs:function(t){this._latlngs=this.options.dash<1?this._generate_GeodesicDashed(t):this._generate_Geodesic(t),L.MultiPolyline.prototype.setLatLngs.call(this,this._latlngs)},getStats:function(){var t,a,n={distance:0,points:0,polygons:this._latlngs.length}
for(t=0;t<this._latlngs.length;t++)for(n.points+=this._latlngs[t].length,a=0;a<this._latlngs[t].length-1;a++)n.distance+=this._vincenty_inverse(this._latlngs[t][a],this._latlngs[t][a+1]).distance
return n},createCircle:function(t,a){var n,i=[],s=0,e={lat:0,lng:0,brg:0}
for(i[s]=[],n=0;n<=this.options.steps;){var h=this._vincenty_direct(t,360/this.options.steps*n,a),o=new L.LatLng(h.lat,h.lng)
if(Math.abs(o.lng-e.lng)>180){var l=this._vincenty_inverse(e,o),r=this._intersection(e,l.initialBearing,{lat:-89,lng:o.lng-e.lng>0?-INTERSECT_LNG:INTERSECT_LNG},0)
r?(i[s].push(new L.LatLng(r.lat,r.lng)),s++,i[s]=[],e=new L.LatLng(r.lat,-r.lng),i[s].push(e)):(s++,i[s]=[],i[s].push(o),e=o,n++)}else i[s].push(o),e=o,n++}this._latlngs=i,L.MultiPolyline.prototype.setLatLngs.call(this,this._latlngs)},_generate_Geodesic:function(t){var a,n,i,s=[],e=0
for(n=0;n<t.length;n++){for(s[e]=[],i=0;i<t[n].length-1;i++){var h=this._vincenty_inverse(t[n][i],t[n][i+1]),o=t[n][i]
for(s[e].push(o),a=1;a<=this.options.steps;){var l=this._vincenty_direct(t[n][i],h.initialBearing,h.distance/this.options.steps*a),r=new L.LatLng(l.lat,l.lng)
if(Math.abs(r.lng-o.lng)>180){var g=this._intersection(t[n][i],h.initialBearing,{lat:-89,lng:r.lng-o.lng>0?-INTERSECT_LNG:INTERSECT_LNG},0)
g?(s[e].push(new L.LatLng(g.lat,g.lng)),e++,s[e]=[],o=new L.LatLng(g.lat,-g.lng),s[e].push(o)):(e++,s[e]=[],s[e].push(r),o=r,a++)}else s[e].push(r),o=r,a++}}e++}return s},_generate_GeodesicDashed:function(t){var a,n,i,s=[],e=0
for(n=0;n<t.length;n++){for(s[e]=[],i=0;i<t[n].length-1;i++){var h=this._vincenty_inverse(t[n][i],t[n][i+1]),o=t[n][i]
for(s[e].push(o),a=1;a<=this.options.steps;){var l=this._vincenty_direct(t[n][i],h.initialBearing,h.distance/this.options.steps*a-h.distance/this.options.steps*(1-this.options.dash)),r=new L.LatLng(l.lat,l.lng)
if(Math.abs(r.lng-o.lng)>180){var g=this._intersection(t[n][i],h.initialBearing,{lat:-89,lng:r.lng-o.lng>0?-INTERSECT_LNG:INTERSECT_LNG},0)
g?(s[e].push(new L.LatLng(g.lat,g.lng)),e++,s[e]=[],o=new L.LatLng(g.lat,-g.lng),s[e].push(o)):(e++,s[e]=[],s[e].push(r),o=r,a++)}else{s[e].push(r),e++
var M=this._vincenty_direct(t[n][i],h.initialBearing,h.distance/this.options.steps*a)
s[e]=[],s[e].push(new L.LatLng(M.lat,M.lng)),a++}}}e++}return s},_vincenty_direct:function(t,a,n){var i,s=t.lat.toRadians(),e=t.lng.toRadians(),h=a.toRadians(),o=n,l=this.datum.ellipsoid.a,r=this.datum.ellipsoid.b,g=this.datum.ellipsoid.f,M=Math.sin(h),c=Math.cos(h),p=(1-g)*Math.tan(s),u=1/Math.sqrt(1+p*p),d=p*u,_=Math.atan2(p,c),v=u*M,L=1-v*v,f=L*(l*l-r*r)/(r*r),y=1+f/16384*(4096+f*(-768+f*(320-175*f))),I=f/1024*(256+f*(-128+f*(74-47*f))),N=o/(r*y),R=0
do{var P=Math.cos(2*_+N),m=Math.sin(N),b=Math.cos(N),E=I*m*(P+I/4*(b*(-1+2*P*P)-I/6*P*(-3+4*m*m)*(-3+4*P*P)))
i=N,N=o/(r*y)+E}while(Math.abs(N-i)>1e-12&&++R)
var T=d*m-u*b*c,w=Math.atan2(d*b+u*m*c,(1-g)*Math.sqrt(v*v+T*T)),G=Math.atan2(m*M,u*b-d*m*c),D=g/16*L*(4+g*(4-3*L)),B=G-(1-D)*g*v*(N+D*m*(P+D*b*(-1+2*P*P))),C=(e+B+3*Math.PI)%(2*Math.PI)-Math.PI,S=Math.atan2(v,-T)
return{lat:w.toDegrees(),lng:C.toDegrees(),finalBearing:S.toDegrees()}},_vincenty_inverse:function(t,a){var n,i=t.lat.toRadians(),s=t.lng.toRadians(),e=a.lat.toRadians(),h=a.lng.toRadians(),o=this.datum.ellipsoid.a,l=this.datum.ellipsoid.b,r=this.datum.ellipsoid.f,g=h-s,M=(1-r)*Math.tan(i),c=1/Math.sqrt(1+M*M),p=M*c,u=(1-r)*Math.tan(e),d=1/Math.sqrt(1+u*u),_=u*d,v=g,L=0
do{var f=Math.sin(v),y=Math.cos(v),I=d*f*d*f+(c*_-p*d*y)*(c*_-p*d*y),N=Math.sqrt(I)
if(0==N)return 0
var R=p*_+c*d*y,P=Math.atan2(N,R),m=c*d*f/N,b=1-m*m,E=R-2*p*_/b
isNaN(E)&&(E=0)
var T=r/16*b*(4+r*(4-3*b))
n=v,v=g+(1-T)*r*m*(P+T*N*(E+T*R*(-1+2*E*E)))}while(Math.abs(v-n)>1e-12&&++L<100)
if(L>=100)return console.log("Formula failed to converge. Altering target position."),this._vincenty_inverse(t,{lat:a.lat,lng:a.lng-.01})
var w=b*(o*o-l*l)/(l*l),G=1+w/16384*(4096+w*(-768+w*(320-175*w))),D=w/1024*(256+w*(-128+w*(74-47*w))),B=D*N*(E+D/4*(R*(-1+2*E*E)-D/6*E*(-3+4*N*N)*(-3+4*E*E))),C=l*G*(P-B),S=Math.atan2(d*f,c*_-p*d*y),q=Math.atan2(c*f,-p*d+c*_*y)
return C=+C.toFixed(3),{distance:C,initialBearing:S.toDegrees(),finalBearing:q.toDegrees()}},_intersection:function(t,a,n,i){var s=t.lat.toRadians(),e=t.lng.toRadians(),h=n.lat.toRadians(),o=n.lng.toRadians(),l=(+a).toRadians(),r=(+i).toRadians(),g=h-s,M=o-e,c=2*Math.asin(Math.sqrt(Math.sin(g/2)*Math.sin(g/2)+Math.cos(s)*Math.cos(h)*Math.sin(M/2)*Math.sin(M/2)))
if(0==c)return null
var p=Math.acos((Math.sin(h)-Math.sin(s)*Math.cos(c))/(Math.sin(c)*Math.cos(s)))
isNaN(p)&&(p=0)
var u=Math.acos((Math.sin(s)-Math.sin(h)*Math.cos(c))/(Math.sin(c)*Math.cos(h)))
if(Math.sin(o-e)>0)var d=p,_=2*Math.PI-u
else var d=2*Math.PI-p,_=u
var v=(l-d+Math.PI)%(2*Math.PI)-Math.PI,L=(_-r+Math.PI)%(2*Math.PI)-Math.PI
if(0==Math.sin(v)&&0==Math.sin(L))return null
if(Math.sin(v)*Math.sin(L)<0)return null
var f=Math.acos(-Math.cos(v)*Math.cos(L)+Math.sin(v)*Math.sin(L)*Math.cos(c)),y=Math.atan2(Math.sin(c)*Math.sin(v)*Math.sin(L),Math.cos(L)+Math.cos(v)*Math.cos(f)),I=Math.asin(Math.sin(s)*Math.cos(y)+Math.cos(s)*Math.sin(y)*Math.cos(l)),N=Math.atan2(Math.sin(l)*Math.sin(y)*Math.cos(s),Math.cos(y)-Math.sin(s)*Math.sin(I)),R=e+N
return R=(R+3*Math.PI)%(2*Math.PI)-Math.PI,{lat:I.toDegrees(),lng:R.toDegrees()}},_merge_options:function(t,a){var n={}
for(var i in t)n[i]=t[i]
for(var i in a)n[i]=a[i]
return n}}),L.geodesic=function(t,a){return new L.Geodesic(t,a)}